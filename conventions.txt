1. Краткое описание React + Redux:

    1.1. Веб интерфейс React, представляет собой машину состояний компонент (Components states) и управляется данными, которые хранятся в едином, благодаря Redux, хранилище Store.

    1.2. Данные в Store представлены в виде набора моделей (Models), каждая из которых с одной стороны описывает структуру и обеспечивает хранение данных определенной сущности или концепции бизнес-логики (conceptual data), с другой стороны, может содержать вспомогательные данные, необходимые для корректного отображения элементов пользовательского интерфейса (ui data), обеспечивающих отображение этих данных в виде представлений (views)

    1.3. Компоненты могут быть подключены к Store при помощи метода Redux.connect и читать из него данные в виде текущего состояния, представленного в компоненте как this.state, либо получать данные от родительских компонент через атрибуты, представленные в компоненте как this.props.

    1.4. Помимо данных, компоненты могут получать в this.props методы, которые могут вызываться, на пример в результате возникновения событий (events), запуская логику, реализованную в родительской (parent) компоненте и обеспечивая таким образом транспорт данных от дочерних компонент (children) к родительской.

    1.5. Компоненты не могут изменять данные, находящиеся в this.store или в this.props, даже если значение попало в this.props не из Store, а сгенерировано логикой компоненты или её родителя. Таким образом данные в this.state и this.props являются неизменяемыми (immutable).

    1.6. Изменение данных в Store обеспечивается функциями редукторами (reducers), путём копирования ссылок на модели из Store во вновь созданный объект, который и возвращается в последствии редуктором, заменяя полностью исходный Stor, а так же путём копирования полей одной или нескольких моделей в другой вновь созданный объект и помещаемый в новый объект Store вместо ссылки на исходную модель.

    1.7. Компоненты могут отправлять в Store действия (actions), содержащие данные, при помощи метода Store.dispatch, который так же доступен в замыкании методов, добавляемых в this.props функцией mapDispatchToProps, передаваемой методу Redux.connect вторым аргументом. 

    1.8. Метод dispatch запускает редуктор, определяемый типом (action.type) переданного ему а аргументе действия, инициируя тем самым изменения Store этим редуктором.

    1.9. Очень краткое описание React + Redux:

    {Store} :> {state} => ({<Component/>}) [=> {props} -> ({<Component/>}) => {event}] => {action} [=> {action}] :> (reducer) :> {Store}

2. Краткое описание шаблона проектирования MVVM:

    2.1. Шаблон проектирования MVVM применяется в ситуации, когда использовается связывание данных с элементами интерфейса (data binding). В классическом понимании чаще всего подразумевается двунаправленное связывание (two way binding), но в целом, эта особенность справедлива и в случае с однонаправленным связыванием, так как оно тоже исключает использование сущностей, на подобии контроллера, полностью отделяющего данные (Model) от представления (View), за счет чего делает невозможным использование таких шаблонов проектирования, как MVC.

    2.2. MVVM состоит из трёх концептуальных частей, Model, View и ViewModel которые выполняют следующее функции:

        2.2.1. Model предназначена для хранения данных и определяет их структуру, представляя собой концептуальное отражение бизнес-логики приложения.

        2.2.2. ViewModel обеспечивает логику построения интерфейса, группируя View компоненты в системы, отражающие определенную часть структуры бизнес-логики.

        2.2.3. Каждое представление View отвечает за отображение определенного компонента интерфейса и обеспечивает взаимодействие пользователя с ним путём подписывания на события элементов. 

    2.3. Очень краткое описание MVVM:
    
    ({Model}) => {data} :> ({ViewModel}) => {update} -> <View/> => {event} -> ({ViewModel}) :> (data) -> ({Model})

3. Рекомендации по применению концепций шаблона MVVM к React в связке с Redux:

    3.1. Гляда на React и Redux в свете MVVM, можно условно сопоставить Store с Model, а компоненты разделить на две категории, одни из которых выполняют роль View, а другие роль ViewModel.

    3.2. Модель (Store) желательно использовать только для хранения и определения структуры данных бизнес-логики. Данные компонент, не касающиеся бизнес-логики и обеспечивающие внтреннюю логику работы компонент, такую как на пример, текст введенный в поле ввода, флаги видимости элементов компонента, состояние элементов управления, на подобии индикации валидности данных и прочие вспомогательные данные должны храниться в this.state соответствующей View компонеты.

    3.3. Компоненты, играющие роль ViewModel, являются элементами, специфичными для конкретного приложения и отражают струтуру интефейса согласно структуре данных бизнес-логики. Эти компоненты могут получать данные из this.state, или из this.props от родительских ViewModel компонент. 
    
    Для даных компонент справедливы следующие утверждения:

        - Отправляют (dispatch) в Store какие либо действия (actions) соответствующим редюсерам (reducer) и не используют this.setState - работают только через отправку действий

        - Могут получать данные как из Store, так и через this.props. Данная особенность позволяет при желании подразделить ViewModel`s на различные категории, обеспечивающие различные типы управления потоками данных бизнес-логики в приложении, такие как на пример:
        
            - коллекции (Collections) - ViewModel`s, получающие данные из Store и распределяющие их по свойствам props других ViewModel`s
                примеры: <Users/>, <Cars/>, <Reports/>, ...
        
            - листья (Items) - ViewModel`s, получающие данные только через this.props, исключительно для собственного использования
                примеры: <User/>, <Car/>, <Report/>, ...
        
            - субъекты (Subjects) - ViewModel`s, получающие данные из Store, исключительно для собственного использования
                примеры: <SupportInfo/>, <AboutUs/>, <Copyright/>, ...
        
            - посредники (Proxyes) - Сущности, получающие данные через props, и транслирующие их в props другим ViewModel`s
                примеры: <CurrencyConvertor/>, <NDSCalculator/>, ...
        
            - ...а так же разные комбинации, в зависимости от потребностей бизнеслогики. Такое подразделение может быть использовано как исключительно формально, только на уровне терминологии, так и на уровне реализации в коде, для чего потребуется построить иерархию наследования классов, на пример React.Component -> Collection -> UserList
        
        - Не определяют как выглядит интерфейс и используют стили в самых крайних случаях, но в идеале не используют стилей вообще - это важно, так как основная задача ViewModel`s не визуальное представление данных, а обеспечение взаимосвязи средств их отображения, коими являются View`s, с данными бизнес-логики, абстрагируя тем самым структуру интерфейса от стрктуры данных.

    3.4. Компоненты играющие роль View, реализуют представление стандартных элементов управления, позволяющих отображать данные, или обеспечивать ввод данных не зависимо от роли этих данных в бизнес-логике приложения, за счет чего могут быть использованы во множестве разных проектов. Эти компоненты отличаются стандартизированным интерфейсом (API) и получают данные исключетельно через this.props, а сгенерированные, или введённые пользователем данные, учавствующие в жизненном цикле бизнес-логики приложения, передают в виде аргуметов методов, так же преданных им посредством this.props родительскими элементами. 

    Для данных компонент справедливы следующие утверждения:

        - Не отправляют в Store никаких действий - все рабочие данные возвращают в виде аргументов методов, переданных им в this.props в момент их вызова и входящие данные, специфичные для бизнес-логики приложения, получают тоже исключительно через this.props, при этом в реализации самих View компонент специфичность входящих и исходящих данных ни коим образом не отражена - работа построена с обезличенными структурами данных.

        - данные, специфичные для жизненного цикла самой компоненты и не относящиеся к бизнес-логике, хранят в this.state и изменяют их при помощи метода this.setState.

        - Формат методов и данных, получаемых компонентой View в this.props, определяется самой компонентой через регламент API этой компоненты, отраженный в поле класса this.propsTypes и не зависит ни коим образом от специфики бизнес-логики приложения, другими словами, этот интерфейс не может определяться потребностями родительских для View компонент

        - Не могут быть явным родительским элементом классa ViewModel, так как если он импортирует модуль с классом, специфичным для терминов бизнес-логики, он сам становится специфичным и теряет свойство переносимости. В качестве исключения можно рассмотреть View, которые не импортируют ViewModel, а используют this.props.children, если ViewModel добавлена к нему в качестве дочернего элемента на верхнем уровне:
        
            Допустимо:

                //some-view.js
                let SomeView = React.createClass({
                    ...
                    render() {
                        return <div>{this.props.children}</div>;
                    }
                });

                // parent-module.js
                let SomeView = require('some-view');
                let SomeViewModel = require('some-view-model');
                ...
                render() {
                    ...
                    <SomeView>
                        <SomeViewModel/> // SomeView работает с this.props.children и ни чего не знает о SomeViewModel
                    </SomeView>
                    ...
                }
                
            Не правильно:

                //some-view.js
                let SomeViewModel = require('some-view-model');
                ...
                let SomeView = React.createClass({
                    ...
                    render() {
                        return <div><SomeViewModel/></div>;
                    }
                });

                //parent-module.js
                let SomeView = require('some-view');
                ...
                render() {
                    ...
                    <SomeView/> // SomeView уже не является простым переносимым элементом, так как использует логику, специфичную для конкретного приложения
                    ...
                }
        
        - Используют стили, опираясь преимущественно на селекторы классов, в которых так же полностью исключаются термины бизнес-логики. Каждая компонента View, определяет только то, как выглядит она сама и может еще модификаторы, корректирующие отображение дочерних компонент, которыми, как было сказано выше, могут быть только View компоненты, а значит в стилях приложения в идеале должны быть полностью исключены любые связи с понятиями. специфичными для бизнес-логики конкретного приложения, а если и возникает такая необходимость, то такие стили объявляются только для элементов ViewModel компонент, при чем, если такая необходимость и возникает, то это является сигналом о том, что приложение может быть существенно оптимизировано в той части, где такая потребность возникла.
